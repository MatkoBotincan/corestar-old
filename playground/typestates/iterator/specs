//{{{ Issues
// * finalize: we need a logic rule that is applied only if necessary
// * rewrite rules for read/write predicates
// * @caller, @return, @this
// * do we need xor? (this state `xor' that state)
// * what's the scope for abstract predicate names?
//}}}
//{{{ List
class List {
  static void <init>() : {} {};
  static void add(java.lang.Object) : {} {};
  static int size() : {} {};
  static Iterator iterator() : {} {};
  static void remove(java.lang.Object) : {} {};
}
//}}}
//{{{ List$LI
class List$LI {
}
//}}}
//{{{List$Node
class List$Node {
}
//}}}
//{{{ Collection
class Collection {
  static void add(java.lang.Object) : 
      {write(@caller,@this:,_r,_w)}
      {write(@caller,@this:,_r,_w)};
  static void remove(java.lang.Object) : 
      {write(@caller,@this:,_r,_w)}
      {write(@caller,@this:,_r,_w)};
  static int size() : 
      {read(@caller,@this:,_r,_w)}
      {read(@caller,@this:,_r,_w)};
  static Iterator iterator() : 
      {write(@caller,@this:,_r,Z)} 
      {validIterator($ret_val,{c=@this:;r=_r})};
}
//}}}
//{{{ Iterator
class Iterator {
  define trueHasNext(x,c=c;r=r) = write(this, c, r, Z);
  define falseHasNext(x) = ;
  define validIterator(x,c=c;r=r) = 
      trueHasNext(x,{c=c;r=r})
      || (falseHasNext(x) * write(@caller,_c,_r,Z));
  static boolean hasNext() : 
      {falseHasNext(@this:)} 
      {falseHasNext(@this:) * $ret_val=False} // TODO(rgrig): =False is redundant
    andalso
      {trueHasNext(@this:)}
      {trueHasNext(@this:) * $ret_val=True};
  static java.lang.Object next() : 
      {trueHasNext(@this:,{c=_c;r=_r})} // TODO(rgrig): (inner) {} should be optional
      {validIterator(@this:,{c=_c;r=_r})};
}
//}}}
//{{{ Client
class Client {
}
//}}}

